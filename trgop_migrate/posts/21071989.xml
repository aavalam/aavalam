<item>
	<title>Exception to Rule: String Class and to_s and to_str</title>
	<link>http://vgoff.posterous.com/strings-and-tos-and-tostr</link>
	<pubDate>Fri Jun 25 08:33:00 -0700 2010</pubDate>
	
	<dc:creator><![CDATA[Victor Goff]]></dc:creator>
	
	
		<category domain="tag" nicename="ruby"><![CDATA[ruby]]></category>
	
		<category domain="tag" nicename="string"><![CDATA[string]]></category>
	
		<category domain="tag" nicename="to_s"><![CDATA[to_s]]></category>
	
		<category domain="tag" nicename="to_str"><![CDATA[to_str]]></category>
	

	<category><![CDATA[Uncategorized]]></category>

	<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>

  <guid isPermaLink="false">http://vgoff.posterous.com/strings-and-tos-and-tostr</guid>
	<description></description>
	<content:encoded><![CDATA[<p>One of the sample programs given while learning Ruby can be an
Unpredictable String that is a subclass of String.  This exercise can
bring up some nuances that otherwise may not be learned.  Of course,
the original lesson is subclassing, and using the super class for
functionality.</p>

<p>But, if you dig into it a little bit further, to really make the
UnpredictableString unpredictable, you soon find out that your
expectations on how string interpolation works just doesn&rsquo;t follow on
with this subclass, due to being a #kind_of?(String).</p>

<p>See <a href="http://www.cmplngrb.tk/to_s-and">http://www.cmplngrb.tk/to_s-and</a> for an in depth discussion on this
in the comments, especially starting about halfway down..  I have so
far seen no way to enforce the use with a class subclassing String
though.</p>]]></content:encoded>
	<excerpt:encoded><![CDATA[One of the sample programs given while learning Ruby can be an Unpredictable String that is a subclass of String. This exercise can bring up some nuances that otherwise may not be learned. Of course, the original lesson is subclassing, and using t...]]></excerpt:encoded>	

	<wp:post_date>Fri Jun 25 08:33:00 -0700 2010</wp:post_date>
	<wp:post_date_gmt>%= display_date %></wp:post_date_gmt>
	<wp:comment_status>open</wp:comment_status>
	<wp:ping_status>open</wp:ping_status>
	<wp:post_name>exception-to-rule-string-class-and-tos-and-to</wp:post_name>
	<wp:status>publish</wp:status>
	<wp:post_parent>0</wp:post_parent>
	<wp:menu_order>0</wp:menu_order>
	<wp:post_type>post</wp:post_type>
	<wp:post_password></wp:post_password>
	<wp:is_sticky>0</wp:is_sticky>

	
		<wp:comment>
			<!-- <wp:comment_id>5</wp:comment_id> -->
			<wp:comment_author><![CDATA[marcric]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_date>Sun Jun 27 06:55:48 -0700 2010</wp:comment_date>
			<wp:comment_date_gmt>Sun Jun 27 06:55:48 -0700 2010</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I still didn't understand which is the point...

Duck typing doesn't work that way, period. http://tw0.us/Hvl

The guy has an Array object full of different kinds of item objects, and try to inject they all into a string.

Here is the thing:

list = [1, 2.3, 'four', false]
puts list
puts '============'
puts list.respond_to?(:to_str)
puts list.class
puts '============'
list.each {|i| puts i.class}

It works and shows what is going on.

Or not?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
		</wp:comment>
	
		<wp:comment>
			<!-- <wp:comment_id>5</wp:comment_id> -->
			<wp:comment_author><![CDATA[]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_date>Mon Jun 28 19:46:58 -0700 2010</wp:comment_date>
			<wp:comment_date_gmt>Mon Jun 28 19:46:58 -0700 2010</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Yes, it works, but you are not really doing anything with each individual object other than displaying them.

I think the point is that if we were to do something (or rather attempt) with 'four' as a string, if it quacks like an array (can split) and walks like an array (can sort) then we can assume it is array enough to do those things, and maybe index them, and do some basic comparisons to a true Array object.

This means that if I implement to_str on my class, I should probably implement other behaviors that are minimally expected of a string in my class so that other objects that see mine can say &quot;That looks like a Duck!  Let's use it!&quot; and have some success.

This brings up another point though, respond_to?() is not duck typing.  It is simply a check.  Duck Typing is more of a superficial observance.  If something appears like a Duck it isn't necessarily a duck.  It does mean that duck-like objects can be processed, regardless of their true &quot;duckiness&quot;.  It doesn't mean that treating something exactly like a duck when it is duck-like isn't going to fail.  It just means that you may get further with it than you would otherwise.

With Ruby 1.9 removing to_str from even Exception class (String now is the only built in class with to_str() ) this means we now have one point of functionality to determine if our class is &quot;Like a Duck&quot; by determining if to_str method is available (responds_to?), and acting on that as though it is a string.
]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
		</wp:comment>
	
</item>
